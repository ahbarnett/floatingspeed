FLOATINGSPEED

Compare single-core real and complex arithmetic performance on arrays
in C, C++, and Fortran.  The task is mostly memory-bounds (a couple of
flops per array entry).  One point is to compare C complex.h vs C++
complex vector arithmetic, and ensure no slower than Fortran native
complex arithmetic.

Alex Barnett, Jeremy Magland, with advice from Andras Pataki.

Version of 3/28/17

To compile and perform all tests on linux system with GCC, run: 

   ./do_complextimings.sh

See results/complextiming_results*.txt for results with various flags
on various machines.

Summary:

i7 (laptop): -Ofast with either -funroll-loops or -march=native is
best, and all complex types are the same speed, around 2x slower than
real.  Fortran, C and C++ are all equally fast for complex arithmetic
using their native types (complex.h for C, and <complex> for
C++). std::vector doesn't add any overhead.  With only -Ofast, C++
std::complex<double> is 40% slower than C-type.

xeon (desktop): -Ofast is best (unroll-loops doesn't hurt).  C++
std::complex<double> is 40% slower than C-type even for this best
setting. -march=native actually hurts the xeon, around 10% slower.
Conclusion is: avoid std::complex<double> and march=native. Use
C-type complex.

Notes:

1) Strict IEEE compliance is a huge speed hit in C and C++.
-Ofast enables -ffast-math, which removes the function call and
conditionals about Infs, Nans, etc, compiled into the assembly code to
make strict IEEE-compliant complex arithmetic in the usual
optimizations up to -O3.  With only -O3 complex types run slower than
hand-coded real arithmetic.

2)
Doing it by hand with RRR..III... storage is silly anyway and adds 10%
overhead. By hand with RIRIRI... storage is no faster than complex types
in either C or C++.

3) Enable either USE_C_TYPE_COMPLEX or USE_CPP_TYPE_COMPLEX in the C++ code.

4) Each operation is a multiplication and an addition. That way the result is accumulated (see next note)
(I also created a new version of the fortran to use the same computation)

5) The result of the computation is printed out, so we are sure we are doing the same thing in each run.

6) Scope {} around each section

7) Fixed the random data once and for all at the top, so we can compare results.
